* Notes                                            -*- Mode: Outline -*-

** Things to do

- Implement TRACE-LET (see separate section below)

- Add a pathname library?

- Add foof-loop?  (may not be really necessary, IDK)

- Implement X11 protocol support? (See Common Lisp CLX lib)

- Maybe break out `LET-OPTIONALS` into a separate library?

- Consider stealing interesting things from MIT Scheme such as
  `STAR-PARSER`

- Add various interesting codez from
  <https://mumble.net/~campbell/scheme/>

- Implement "library aliases", so you can load SRFI-69 code by typing
  e.g. `(load-module 'hash-table)`

- Incorporate some elements of the Scheme Prelude from Programming
  Praxis

- TODO implement trace/untrace (not sure if needed, depends on the
  Scheme)

- TODO Maybe add TinyCLOS support?  Is it a win over YASOS?

- TODO Wrap YASOS to map to Java objects (see the file "inspect.scm"
  for details of how to map across Java object fields)

- TODO implement/integrate a GUI stepper/debugger (perhaps you can
  leverage Bil Lewis' time-traveling debugger?)

** How to list all bound symbols in various Schemes

- Larceny: `oblist`
- Chez: `oblist`
- Gambit: ?
- Chibi: ?
- MIT Scheme: ?
- Chicken: ?
- Kawa 3.0: `environment-fold`
- JScheme 7.2: ?
- Scheme 48 1.9

** TRACE-LET, for tracing of intermediate variables

It would be nice if, when we want to inspect the intermediate values
of a variable, rather than having to write code like this:

    (define (%merge-sort xs pred trace?)
      (let loop ((xs xs) (result '()))
           ...
           (if trace?
             (begin
               (display (first xs))
               (newline)
               (display (second xs))
               (newline)
               (newline)
               (loop ...))
            (loop ...))))

we could instead write code like this:

    (define (%merge-sort xs pred trace?)
      (trace-let loop ((xs xs) (result '()))
              ... normal algorithm ...
              ...))

In this hypothetical reality, `TRACE-LET` watches the values of all
variables and prints their value each time through the loop.

I guess it will be implemented as syntax, but we'll see.

Also, it's not clear that this is the best name for it.

Oh!  And actually, it might be better to implement this in a similar
fashion to `LOAD-MODULE`, where it just rewrites whole batches of
Scheme code to generate the output needed, rather than asking the user
to manually rewrite the text of procedures.

See also:

- Source code of JScheme's "elf/trace.scm"

** How to load SYNTAX-RULES in Gambit

    (load "~~/lib/syntax-case")

** How to load SYNTAX-RULES in JScheme

    (load "elf/basic.scm")
    (load "elf/mbe.scm")

** Supported Schemes

*** Larceny Scheme 0.99

- uuid
- xml
- srfi-8
- srfi-9
- srfi-0
- srfi-16
- srfi-19
- srfi-28
- srfi-2
- srfi-43
- srfi-69
- apropos
- assert
- binary-search
- binary-tree
- destructive-ops
- format
- let-optionals
- mergesort
- pregexp

*** Chez Scheme 9.5

- utils
- srfi-9
- srfi-0
- srfi-2
- apropos
- assert
- binary-search
- binary-tree
- destructive-ops
- format
- let-optionals
- mergesort
- pregexp
- srfi-16
- srfi-19
- srfi-28
- srfi-8

*** JScheme 7.2

Note: You must load support for R5RS DEFINE-SYNTAX into JScheme as
follows before you can use LOAD-MODULE.

    (use-module "elf/basic.scm")
    (use-module "elf/mbe.scm")

- pregexp
- destructive-ops
- utils
- assert
- format

*** Scheme 48 1.9.2

- utils
- apropos
- assert
- format
- binary-search
- binary-tree
- destructive-ops
- let-optionals
- mergesort
- pregexp
- srfi-0
- srfi-16
- srfi-28
- srfi-2
- srfi-43
- srfi-69
- srfi-8
- srfi-9
- utils
- uuid
- xml

*** Kawa 3.0 (git describe: 3.0-0-g39797ea94)

** READ-LINE behavior in Larceny vs. Chez vs. Scheme48

There seems to be some difference in the way the same user
implementation of READ-LINE entered at the top-level behaves in
Larceny 1.3 vs. Chez 9.5 vs. Scheme48 1.9.

In Larceny, if I use the built-in READ-LINE, the following code
works as expected:

    (define (map-lines file)
      (call-with-input-file file
        (lambda (port)
          (let loop ((line (read-line port))
                     (lines '()))
            (if (eof-object? line)
                (reverse lines)
                (loop (read-line port)
                      (cons line lines)))))))

    > (map-lines "awk-data.txt")
    ("Beth\t4.00\t0"
     "Dan\t\t3.75\t0"
     "Kathy\t4.00\t10"
     "Mark\t5.00\t20"
     "Mary\t5.50\t22"
     "Susie\t4.25\t18")

If I enter the following implementation of READ-LINE at the Larceny
top-level, the MAP-LINES output changes -- a new empty string is added
in between each line.

    (define (read-line port)
      ;; Port -> String
      (let ((sep #\newline))
        (let loop ((chars '())
                   (this-char (read-char port))
                   (next-char (peek-char port)))
          (cond
           ((eof-object? next-char) next-char)
           ((char=? next-char sep) (list->string (reverse chars)))
           (else (loop (cons this-char chars)
                       (read-char port)
                       (peek-char port)))))))

    > (map-lines "awk-data.txt")
    ("Beth\t4.00\t"
     ""
     "Dan\t\t3.75\t"
     ""
     "Kathy\t4.00\t1"
     ""
     "Mark\t5.00\t2"
     ""
     "Mary\t5.50\t2"
     ""
     "Susie\t4.25\t1"
     "")

If I switch to Chez 9.5, which apparently does not export its own
version of READ-LINE to the top-level by default, and use the above
user implementations of READ-LINE and MAP-LINES, it works as expected:

    > (map-lines "awk-data.txt")
    ("Beth\t4.00\t0"
    "Dan\t\t3.75\t0"
    "Kathy\t4.00\t10"
    "Mark\t5.00\t20" 
    "Mary\t5.50\t22" 
    "Susie\t4.25\t18")

In Scheme 48 1.9, which also does not export its own version of
READ-LINE to the top-level by default, the user implementations of
READ-LINES and MAP-LINES behave as expected (similarly to Chez, and
differently from Larceny):

    > (map-lines "awk-data.txt")
    ("Beth\t4.00\t0"
    "Dan\t\t3.75\t0"
    "Kathy\t4.00\t10"
    "Mark\t5.00\t20" 
    "Mary\t5.50\t22" 
    "Susie\t4.25\t18")

** The JScheme Manual

*** User Manual

**** Downloading JScheme

Downloading the jscheme.jar file

The simplest way to access Jscheme is just to download the jscheme.jar file and put it on your classpath.

Once jscheme.jar is downloaded, you can put it in your classpath, and run it as an interpreter:

    % java jscheme.REPL
    > (* 12345679 8)
    98765432
    > (exit)
    %

or as a Scheme->Java compiler:

    % cat > Hello.scm
    (display "Hello World") (newline)
    ^D
    % java jsint.Compile Hello.scm
    % javac Hello.java
    % java Hello
    Hello World
    %

**** Downloading the source distribution from the CVS server

If you want the entire source distribution, then you can use the anonymous CVS download facilities at sourceforge.net to download and build Jscheme. Jscheme sourceforge site You can download the source code directly using anonymous CVS as follows:

    % cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/jscheme login
     (when prompted for a password for anonymous, simply press the Enter key)
    % cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/jscheme co jscheme

Occasionally, Sourceforge changes the name of the cvs host (its happened twice so far). If the above instructions don't work, try the official sourceforge instructions. You can then build jscheme.jar from the source as follows:

Under Linux or Mac OS X: Run the src/build/bootstrap script from the toplevel of the jscheme folder, after making sure that the JDK has been installed on your system:

      % cd jscheme
      % bin/make
      %
      % java -cp lib/jscheme.jar jscheme.REPL
      > (java.util.Date.)
      Mon Jan 07 14:53:23 EST 2002
      > ....

Under Windows: Run the build/bootstrap.bat script from the toplevel of the jscheme folder, after making sure that the JDK has been installed on your system:

      % cd jscheme
      % bin/make
      %
      % java -cp lib/jscheme.jar jscheme.REPL
      ....

This creates a file jscheme.jar in the jscheme/lib folder.

**** The JScheme Command Line

Assuming that jscheme.jar is on your classpath, you can invoke a Scheme interpreter using

    % java jscheme.REPL file1 file2 file3 ... '(expr1)' '(expr2)'
    > ...

Jscheme can also be supplied command line arguments that will load several files (file1, file2, ...) and evaluate several expressions ( (expr1) (expr2) ...). The files and expressions are loaded or evaluated in the order they appear on the command line. Thus the following command

    % java jscheme.REPL file1 '(expr1)' file2 '(expr2)' file3 ...
    >

is equivalent to

    % java jscheme.REPL 
    > (load "file1")
    > (expr1)
    > (load "file2")
    > (expr2)
    > (load "file3")
    > ...

Finally, you can make pass command line arguments to a Scheme procedure using the "-main" argument to specify the procedure name and the sequence of arguments, as follows:

    % java jscheme.REPL test.scm -main rundemo a "this is a test" 123
    >

The arguments are passed as an array of strings to the procedure whose name specified after the "-main" argument. That is, this is equivalent to:

    % java jscheme.REPL
    > (load "test.scm")
    > (rundemo a "this is a test" 123)

**** The JScheme compiler

The JScheme compiler provides one way of compiling a Scheme program Prog.scm into a Java class, Prog.java The compiled program can be loaded into another program using

(packagename.Prog.load)

which behaves exactly the same as

(load "packagepath/Prog.scm")

You can also specify a main procedure in the Scheme program which will
get compiled into a main method of the Java program. We now give an
example to illustrate this process.

First we create a test file to compile. Note that the compiler
requires you to explicitly import all classes, even the java.lang
classes (you could also use the full name java.lang.System.out$). Also
note that you can access the command line args by writing a procedure
main with one paramter args. This will be compiled into the public
static void main method of the class and provides a way of accessing
the argument array.

    % cd demo/test
    % cat > Prog.scm
    (import "java.lang.System")
    (import "java.lang.reflect.Array")
    (define (main args)
      (.println System.out$ (java.util.Date.))
      (.println System.out$ (Array.get args 0))
      (System.exit 0)
     )
    ^D
    % cd ../..

Now we compile the program (using the -p switch to set the package and the -v switch to specify verbose output). After compiling to java, we compile the java to byte codes and then run the program

    % java jsint.Compile -v -p demo.test Prog.scm
    % javac Prog.java
    % java demo.test.Prog "Hello, World"
    Sat Apr 13 10:42:25 EDT 2002
    Hello, World
    %

Compiler switches:

    "-p PACKAGE" is the switch for setting the package name for the compiled Jscheme program.
    "-v" ... verbose mode 

The JScheme Applet

If you download the source distribution, then you can visit the file
   
src/contrib/jswebapp/jscheme/demo/JSchemeEvaluator.html

which provides an applet for writing and running Scheme code.

**** Calling JScheme from Java

Using a Single Static JScheme Evaluator

Jscheme can be called from Java using the JS class which evaluate expressions in a single statically defined JScheme evaluator.

For example, you can:

    Initialize an application by loading Scheme expressions from a file:

          JS.load(new java.io.FileReader("app.init"));
        

    Run the Scheme procedure (describe) to describe the current object like this:

        JS.call("describe", this);
        

    If you need to call a procedure with more than three arguments use apply().
    Evalute a string as an expression:

        String query = "(+ (expt (Math.sin 2.0) 2) (expt (Math.cos 2.0) 2))";
        System.out.println(query + " = " + JS.eval(query));
        

Unit test:

   (assert (equal? (+ 2 3) (JS.eval '(+ 2 3))))
   (assert (= (+ 2 3) (JS.eval "(+ 2 3)")))
   (assert (= (+ 2 3) (JS.call "+" 2 3)))
   (assert (= (+ 2 3) (JS.call + 2 3)))
   (assert (= (+ 2 3) (JS.apply "+" (JS.list 2 3))))
   (JS.load "(define (f x) (+ x (g x))) (define (g x) (* x 3))")
   (assert (= (f 3) 12))

**** Using an Independent JScheme Evaluator

A better approach is to use the new `jscheme.JScheme` class which
allows you to create an independent JScheme evaluator that can be used
just as the static JS class above.

    jscheme.JScheme js = new jscheme.JScheme();
    js.eval("....")
    js.call(a, b,c,d,e);
    ...

*** Reference Manual

Jscheme is a dialect of Scheme which features a simple and comprehensive interface to Java.

- It allows one to access all methods, constructors, and fields for
  any Java classes by name.

- It provides access to Java literals, Java scalar operations, Java
  threads, and Java exception handling.

- Jscheme supports all of the R4RS specification of Scheme, with two
  exceptions: continuations are only partially supported and strings
  are immutable.

The following sections provide a simple description of the syntax and
semantics of Jscheme and highlight those few points where Jscheme
differs from R4RS Scheme:

- Syntax: Literals, Quasi-strings, and s-expressions
- Control: Special Forms, Exception Handling, and Multi-threading
- Java Access: the JavaDot notation
- Built-ins: The R4RS primitives supported by Jscheme
- Modules: The Jscheme module system

**** Syntax

JScheme syntax agrees with R4RS Scheme syntax except for the syntax
for literals (which incorporates all of the Java literal syntax as
well as most of R4RS literal syntax) and string syntax (JScheme allows
multi-line strings and various sorts of quasi-strings as well).

- Literals
- Quasi-strings
- S-expressions

***** Literals

Jscheme Literals are as in Scheme with a few extensions (shown in red)
which allow a simpler interface with Java.

Jscheme also has support for quasi-strings and a heavier but more
powerful strong quasi-string notation. These both provide a simple way
to generate complex string data in Scheme (e.g. generating HTML, SQL
queries, Java code, Jython code,....)

The null pointer value:

    #null

Boolean values -- the true and false values:

    #t
    #f

Integer values: we allow all Java syntax for integers, e.g.

         12               -- an integer, the default 
         040              -- octal
         0xFFCCAA         -- hex
         132L             -- a long

Floating point values: we allow all Java floating point syntax,

     
        123.45            -- a double, the default  
          1.2345E-2       -- scientific notation for doubles
        123.45F           -- a float
         42D              -- a double 

Characters: Jscheme allows either Scheme syntax or Java syntax, where the latter has a prepended # sign:

        #\space           -- scheme syntax
        #\a               -- scheme syntax  
        #'a'              -- java-like syntax 
        #'\n'             -- java-like syntax
        #'\040'           -- octal escapes
        #'\u4FA3'         -- unicode escapes 

Strings and Symbols: as in Scheme

        "ab\n\040\uAAC4" -- a string with various Java escapes
        car             -- a symbol 
        Math.sin        -- a symbol 

***** Quasi-string notation

Quasi-strings provide a mechanism for constructing a complex string where parts of the string are generated by evaluating Scheme expressions.

Quasi-string notation is now the default in Jscheme. There are two flavors of quasi-strings, regular and strong.

****** Regular Quasi-strings

The regular notation allows you to write code in which {...} denotes a
string (instead of "...."). The quasi-string notation also allows you
to escape into Scheme using [...] to generate an expression which will
be inserted into the string. In quasi-strings you quote the curly
braces {} and the square brackets [] which you want to appear
literally in the string by preceding them with a backslash:

           \{   \}  \[  \]

You don't need to quote the double quotes, which is convenient for
HTML generation.

For example, the following procedure creates an li element with class attribute c:

    > (define (li c x) {<li class="[c]">[x]</li>})
    li

    > (li 'warning {<a href="#licence">Licensing information</a>})
    <li class="warning"> <a href="#licence">Licensing information</a> </li>

The quasistring notation is converted (at read time) into the
following scheme code

      (define (li c x) (string-append "<li class=\"" c "\">" x "</li>"))

Because []{} have a special role in Jscheme, they must not appear in
variables or symbols. There is one exception which is that the pair of
characters [] may appear inside symbols names, thus

    (define types '(Object Object[] java.lang.String[]))

is allowed.

****** Strong Quasi-string notation

One problem with the quasi-string notation is that you still need to
quote the close curly braces and open square brackets that occur
within. This is inconvenient when generating program code that
contains many curly braces and square brackets (e.g. javascript, CSS,
or Java code).

The Strong Quasi-string notation provides a simple solution. The idea
is to use #{ and }# instead of { and }, and to escape from the strong
quasi-strings using #[ and ]# instead of [ and ]. For example, we
write a program that generates a Java class

    > (define  (prog version)
    #{
         public class Test {
            int [] a = new int[] { 1,2,3,4,5};
            String version = "#[ version ]#";

           public static void main(String[] args) {;}
        }
    }#
    )
    (lambda prog (version)...)


    > (begin (display (prog "abc 6/16/04")) (newline) (newline) 'yes)

         public class Test {
            int [] a = new int[] { 1,2,3,4,5};
            String version = "abc 6/16/04";

           public static void main(String[] args) {;}
        }


    yes

    >

Nothing prevents you from nesting quasi-strings inside
strong-quasi-string escapes, or vice-versa, e.g.

     #{ some text #[ (list 'and 'an {excape "here" with reg quasi-strings }) ]# more text }#

The idea is that strong quasi-strings are useful when quoting program
text, but standard quasi-strings are more convenient for other
text.

***** S-expressions

JScheme syntax is identical to R4RS Scheme syntax except for the
literal and quasi-string syntax described above. In particular, a
JScheme program is a sequence of s-expressions.

An S-expression is one of the following:

- A literal

- Boolean, char, short, int, long, float, double, string

- A quasistring

        {...[---]...[---]...   }  or

        #{...#[---]#...#[---]#...   }

- A sequence of zero or more sexpressions enclosed in parentheses:

        (S1 S2 ... Sn)

- A quoted or quasi-quoted expression (as in R4RS Scheme):

            '(a b c (()) (de f))

            `( 1 () ,(+ 3 4) ,@(3 (4 5) 6) apple )

- A vector (as in R4RS Scheme):

         #(1   'red   1.2)

**** Control
***** Special Forms and Macros inherited from Scheme

Jscheme adopts the standard special forms and macros of R4RS Scheme
and adds a few (in blue) to improve the Java interface (e.g. tryCatch):

    (quote EXPR) or ' EXPR -- intuitively, the quote indicates that
    the EXPR is to be treated as data and should not be evaluated. The
    precise semantics are a little more involved as we must state what
    syntax is allowed inside (e.g. quotes, Java Literals, vectors,
    ...) and how that syntax is treated.

    (begin EXPR1 EXPR2 ... EXPRn) -- this evaluates the expressions in
    order, first EXPR1, then EXPR2. The value of the last expression
    is returned. The non-final expresssions only affect program state
    by their side effects.

    (if EXPR1 EXPR2 EXPR3) -- this first evaluates EXPR1 to get a
    value V. If V is equal to the boolean value #f, then EXPR2 is
    evaluated, otherwise EXPR3 is evaluated.

    (if EXPR1 EXPR2) -- this is implemented as (if EXPR1 EXPR2 #f)

    (or EXPR1 EXPR2 ...) -- The expressions are evaluated in order
    until either one evaluates to a value V not equal to #f or all
    expressions are evaluated. In the former case, V is returned, in
    the latter #f is returned.

    (and EXPR1 EXPR2 ...) -- The expressions are evaluated in order
    until one of the expressions evaluates to #f or the end of the
    list is reached. If there are no expressions, then #t is returned;
    otherwise, the value of the last expression to be evaluated is
    returned.

    (set! VAR EXPR) -- Here VAR must be a global or local scheme
    variable or a Java Literal representing a static Java variable. In
    each case, the EXPR is evaluated and its value is assigned to the
    variable.

    (define VAR EXPR ) -- This adds the VAR to the (local or global)
    environment, and assigns it the value V obtained by evaluating
    EXPR.

    (define (VAR0 VAR1 ... VARN) EXPR1 ... EXPRN ) -- this is
    equivalent to (define VAR0 (lambda (VAR1 ... VARN) EXPR1 ... EXPRN))

    (lambda (V1 ... VN) EXPR1 ... EXPRM) -- this creates a closure
    C. When the closure is applied to N values A1 ... An, a new
    environment is created in which Ai is bound to Vi, and the
    expressions are evaluated in order, the value of the last
    expression is returned.

    (lambda (V1 ... VN . R) EXPR1 ... EXPRM) -- This closure can be
    applied to a N or more arguments. R is then bound to the list
    containing all arguments after the Nth.

    (lambda R EXPR1 ... EXPRM) -- This closure can be applied to a
    list of 0 or more arguments. R is bound to the list of arguments.

    (cond (EXPR1a EXPR1b ... EXPR1z) .... (EXPRNa ... EXPRNz))

    (quasiquote EXPR) or ` EXPR -- the quasiquote

    (unquote EXPR) or , EXPR -- (must appear in quasiquoted
    expression)

    (unquote-splicing EXPR) or ,@ EXPR -- (must appear in quasiquoted
    expression)

    (let ((V1 EXPR1) .... (Vn EXPRN)) E1 ... EM)

    (let V0 ((V1 EXPR1) .... (Vn EXPRN)) E1 ... EM)

    (let* ((V1 EXPR1) .... (Vn EXPRN)) E1 ... EM)

    (letrec ((V1 EXPR1) .... (Vn EXPRN)) E1 ... EM)

    (case EXPR ((C1a ... C1z) EXPR1) .... (Vn EXPRN)) E1 ... EM)

    (do ((V1 EXPR1) .... (Vn EXPRN)) E1 ... EM)

    (delay EXPR)

***** JScheme extensions to the control structure of Scheme


(tryCatch EXPR F) this evaluates the EXPR to obtain a return value V;
if, however, a Java exception E is thrown, it calls (F E) to obtain a
return value, e.g.,

      (define (string->double S) 
          (tryCatch (Double. S) (lambda (e)
             (throw (RuntimeError. "Number format error")))))
      (string->double "1.2e3")
      (string->double "1.2e 3")

(define-macro name (lambda ...)) When the macro "name" is applied to
its arguments, it generates an expression which is then passed back to
the evaluator.

      (define-macro (newif Test Then Else) `(if ,Test ,Then ,Else))
      (define-macro when (lambda (Test . Actions) `(if ,Test (begin . ,Actions))))

Thunks are runnable objects. This allows Jscheme to easily implement
multi-threading.

    (define (loop N D) 
        (tryCatch (begin (Thread.sleep D) (display N) (newline) (loop (+ N 1) D))
                  (lambda (e) (display (list "thread interrupted" e)) (newline))))
    (define s (Thread. (lambda() (loop 0 1000L))))
    (define t (Thread. (lambda() (loop 0 5000L))))
    (.start s)
    (.start t)
    (.suspend t)
    (.resume t)
    (.stop s)
    (.stop t)

(define-method ....) -- this has the same syntax as define except that
the parameters can have the form (NAME Type) instead of just NAME,
where Type is a Java class name, e.g.

    (define-method (iterate (items Iterator) action)
      (if (.hasNext items)
          (begin (action (.next items))
                 (iterate items action))))

    (define-method (iterate (items Collection) action)
      (iterate (.iterator items) action))

    (define-method (iterate (items Map) action)
      (iterate (.entrySet items) action))

    (define-method (iterate (items jsint.Pair) action)
      (action (car items))
      (let ((items (cdr items)))
        (if (pair? items) (iterate items action))))

    (define-method (iterate (items Object[]) action)
      (let loop ((i 0) 
                 (L (vector-length items)))
        (if (< i L) (begin (action (vector-ref items i)) (loop (+ i 1) L)))))

    (define (printit x) (.println System.$out x))
    (iterate '(1 2 3 4) printit)
    (iterate (list->vector '(1 2 3 4)) printit)
    ...

(time EXPR [OptionalNumRepeats]) This little macro lets you time
operations.

**** Java Access

***** The Java Dot Notation

The Java Dot Notation provides Jscheme with full access to all Java
constructors, methods, and fields for all Java classes on the current
classpath. The syntax is very simple as explained in the box below and
demonstrated in the examples on the rest of this page.

Java literals have the same syntax as Java members except for a
possible "." or "$" prefix or suffix. Overloaded methods and
constructors are disambiguated dynamically at runtime. Adding a "#" to
the end of a Javadot symbol allows access to private fields, methods,
and constructors (and to members with protected, package, and public
visibility as well).

Syntax	Type of Member	Example
"." at the end 	constructor	(Font. NAME STYLE SIZE)
"." at the beginning 	instance member	(.setFont COMP FONT)
"." at beginning and "$" at the end 	instance field	(.first$ '(1 2))
"." only in the middle 	static member	(Math.round 123.456)
".class" suffix 	Java class	Font.class
"$" at the end 	static field	Font.BOLD$
"$" in the middle 	inner class	java.awt.geom.Point2D$Double.class
"$" at the beginning 	packageless class	$ParseDemo.class
"#" at the end 	private access	(.jsint.Symbol.name$# 'a)

***** Examples of Java Literals

The import statement allows Java package names to be omitted in Java literals, just as in Java:

(import "java.awt.*")	; => import java.awt.*;

A constructor is signified by trailing "." as in "Class."  The
particular constructor is determined dynamically by analyzing the
types of the arguments. The Scheme and corresponding Java would be:

(define win (Frame. "Hello"))
(define L (java.awt.Label. "Hi"))

Frame win = new Frame("Hello");
Label L  = new Label("Hi");

An instance method is signified by a leading "." as in ".Name" The
examples would be written in Scheme and Java as:

(.resize win1 200 300)
(.Container.resize win2 200 300)
(.java.awt.Component.resize win3 200 300)

win1.resize(200, 300);
((Container) win2).resize(200,300);
((java.awt.Component) win3).resize(200,300);

A static method is signified by "." only in the middle as in
"Class.Name".  The examples would be written in Scheme and Java as:

(System.exit 0)
(java.lang.Math.sin 3.1415926) 	

System.exit(0);
java.lang.Math.sin(3.1415926)

A static variable is signified by a "$" at the end and no leading "."
as in "Class.Name$".  The examples would be written in Scheme and Java
as:

(.println System.out$ "hi")
(set! U.useJavaSyntax$ #t)

System.out.println("hi");
U.useJavaSyntax = true;

An instance variable is signified by a "$" at the end and a leading
"." as in ".Class.Name$" or ".Name$".  Instance variables are viewed
as get/set functions, while static variables are viewed as Scheme
variables which can be evaluated and set!'d.  The examples would be
written in Scheme and Java as:

(define a (.Pair.first$ x))
(define b (.SubPair.first$ x))
(define c(.Pair.first$ x newval))
(define d (.SubPair.first$ x newval))

(define L '(1 2 3))
(define e (.first$ L))
(.first$ L 5)

Object a=((Pair)x).first
Object b=((SubPair)x).first
Object c=((Pair)x).first = newval;
Object d=((SubPair)x).first = newval;

Pair L = new Pair(new Integer("1"),
         new Pair(new Integer("2"),
         new Pair(new Integer("3"),Pair.EMPTY)));
Object e = L.first;
L.first= 5;

The suffix ".class" signifies a class literal.  The examples would be
written in Scheme and Java as:

(define c1 Object.class)
(define c2 Line2D$Float.class)
(define c3 int.class)
(define c4 float[][].class )
(define c5 Float[].class)

Class c1 = Object.class;
Class c2 = Line2D.Float.class;
Class c3 = int.class;
Class c4 = float[][].class;
Class c5 = Float[][].class;

Note that in Jscheme, "$" is used to indicate inner classes rather
than "." as used by Java.

Jscheme also provides a mechanism for precisely and unambiguously
specifying a method or constructor by giving its name, class, and
argument types as shown below:

(define win
  (constructor "Frame" "String"))

(define frame-add 
  (method "add" "Frame" "Component"))

**** Built-ins

Jscheme adopts almost all of the [standard
procedures](http://web.archive.org/web/20170517193646/http://people.csail.mit.edu/jaffer/r4rs_8.html)
of [R4RS
Scheme](http://web.archive.org/web/20170515071905/http://people.csail.mit.edu/jaffer/r4rs_toc.html).

It does not fully implement call/cc. Also, while JScheme provides
string mutators string-set! and string-fill!, JScheme strings are
implemented as Java Strings which are considered immutable, so use
these procedures carefully.

The only R4RS primitives that are not fully supported are

    (call-with-current-continuation ) ONLY PARTIALLY IMPLEMENTED
    (complex? ) NOT IMPLEMENTED
    (rational? ) UNIMPLEMENTED
    (real? ) UNIMPLEMENTED 

A list of all essential R4RS primitives is provided below.

    (exact->inexact n ) -- converts an exact number n to an inexact number
    (inexact->exact x ) -- converts an inexact number x to an exact number
    (* x y ... z) multiplies a sequence of numbers
    (+ x y ... z ) adds a sequence of numbers
    (- x y ) subtracts two numbers
    (/ x y ) divides two numbers
    (< x y ) compares two numbers, returns #t if x is less than y
    (<=x y ) compares two numbers, returns #t if x is less than or equal to y
    (= x y) compares two numbers, returns #t if x is equal to y
    (> x y ) compares two numbers, returns #t if x is greater than y
    (>= x y ) compares two numbers, returns #t if x is greater than or equal to y
    (abs x ) the absolute value of x
    (acos x ) the arc cosine of x
    (append x y) appends two lists x y to get a new list
    (apply f arguments ) applies the function f to the list of arguments
    (asin x) the arc sine of x
    (assoc x alist) alist is a list of pairs (key value), if x is one of those keys, the value is returned. equal? is used to compare x and key.
    (assq x alist) Same as assoc, but eq? is used to compare x and key.
    (assv x alist) Same as assoc, but eqv? is used to compare x and key.
    (atan x) the arc tangent of x
    (boolean? b ) #t if b is a boolean value: #t or #f
    (caaaar ) (lambda (x) (car (car (car (car x)))))
    (caaadr ) (lambda (x) (car (car (car (cdr x)))))
    (caaar ) (lambda (x) (car (car (car x))))
    (caadar ) (lambda (x) (car (car (cdr (car x)))))
    (caaddr ) (lambda (x) (car (car (cdr (cdr x)))))
    (caadr ) (lambda (x) (car (car (cdr x))))
    (caar ) (lambda (x) (car (car x)))
    (cadaar ) (lambda (x) (car (cdr (car (car x)))))
    (cadadr ) (lambda (x) (car (cdr (car (cdr x)))))
    (cadar ) (lambda (x) (car (cdr (car x))))
    (caddar ) (lambda (x) (car (cdr (cdr (car x)))))
    (cadddr ) (lambda (x) (car (cdr (cdr (cdr x)))))
    (caddr ) (lambda (x) (car (cdr (cdr x))))
    (cadr ) (lambda (x) (car (cdr x)))
    (call-with-current-continuation ) ONLY PARTIALLY IMPLEMENTED
    (call-with-input-file )
    (call-with-output-file )
    (car L ) the first element in the list L (src)
    (cdaaar ) (lambda (x) (cdr (car (car (car x)))))
    (cdaadr ) (lambda (x) (cdr (car (car (cdr x)))))
    (cdaar ) (lambda (x) (cdr (car (car x))))
    (cdadar ) (lambda (x) (cdr (car (cdr (car x)))))
    (cdaddr ) (lambda (x) (cdr (car (cdr (cdr x)))))
    (cdadr ) (lambda (x) (cdr (car (cdr x))))
    (cdar ) (lambda (x) (cdr (car x)))
    (cddaar ) (lambda (x) (cdr (cdr (car (car x)))))
    (cddadr ) (lambda (x) (cdr (cdr (car (cdr x)))))
    (cddar ) (lambda (x) (cdr (cdr (car x))))
    (cdddar ) (lambda (x) (cdr (cdr (cdr (car x)))))
    (cddddr ) (lambda (x) (cdr (cdr (cdr (cdr x)))))
    (cdddr ) (lambda (x) (cdr (cdr (cdr x))))
    (cddr ) (lambda (x) (cdr (cdr x)))
    (cdr L ) the list obtained by removing the first element from the list L
    (ceiling x ) return the smallest integer greater than or equal to x
    (char->integer )
    (char-alphabetic? )
    ((char-ci<=? C1 C2) ) case-insensitive comparison of characters C1,C2
    (char-ci )
    (char-ci=? )
    (char-ci>=? )
    (char-ci>? )
    (char-downcase )
    (char-lower-case? )
    (char-numeric? )
    (char-upcase )
    (char-upper-case? )
    (char-whitespace? )
    ((char<=? C1 C2) ) case-sensitive comparison of characters
    (char )
    (char=? )
    (char>=? )
    (char>? )
    (char? )
    (close-input-port )
    (close-output-port )
    (complex? ) NOT IMPLEMENTED
    (cons x L ) the list obtained by adding x to the beginning of the list L (src)
    (cos x) the cosine of x in radians
    ((current-input-port) )
    ((current-output-port) )
    (display T ) print the term T on the Java console
    ((eof-object? X) ) returns true if X is the end of file object returned by read
    ((eq? A B) ) returns #t when A and B are both #null or when they are both the same object
    (equal? x y) returns #t if x and y are both #null or represent the same numbers, or are ".equals" as Java objects, or are lists whose corresponding elements are "equal?", or are arrays whose corresponding elements are "equal?". or are
    ((eqv? A B) ) returns #t if x and y are both #null or represent the same numbers, or are ".equals" as Java objects.
    ((eval T) ) this evaluates the expression T in the current toplevel environment. The expression T is an expression formed from symbols and objects cons'd together.
    (even? x) #t if x is an even number
    ((exact? x) ) #t if x is a byte, short, or int
    (exp x ) the exponential function applied to x
    (expt n e ) raise n to the power e
    (floor x) return the largest integer less than x
    (for-each P L ) apply the procedure P to every element of the list L
    (force )
    (gcd x y ) find the greatest common divisor of x and y
    ((inexact? x) ) #t if x is a float or double
    ((input-port? x) )
    ((integer->char i) ) converts i to 16 bit unicode character
    (interaction-environment)Return the current interaction environment.
    (integer? x ) #t if x is an integer
    (lcm x y) return the least common multiple of x and y
    (length L) return the length of the list L
    (list x y ... z) make a list from the elements x, y, ... z
    ((list->string Cs) ) converts the list Cs of characters to a string
    ((list->vector Os) ) converts the list Os of objects to a vector
    ((list-ref L N ) returns the (N+1)st element of L. So (list-ref L 0) returns the first element of L.
    (list-tailL N ) returns the list obtained by removing the first N elements from L
    (list? L) returns #t if L is a list
    (load F) reads and interprets the Scheme expressions in the file F in the current toplevel environment
    (log x) the natural log function applied to x
    (macroexpand X)
    (make-string )
    (make-vector )
    (map F L) return the list obtained by applying the function F to every element of the list L
    (max a b c ... d) find the largest of the numbers a, b, ..., d
    (member x L) return #t if x is a member of the list L
    (memq )
    (memv )
    (min a b c ... d) find the smallest of the numbers a, b, ..., d
    (modulo n d) return the remainder of n divided by d
    (negative? x) return #t if x is a negative number
    (newline) write a newline on the Java console
    (not b) negates the truth value b
    (null-environment )
    (null? L ) return #t if L is the empty list
    (number->string )
    (number? x ) return #t if x is a number
    (odd? x) return #t if x is an odd number
    (open-input-file )
    (open-output-file )
    (output-port? )
    (pair? L) return #t if L is a pair.
    (peek-char )
    (positive? x) return #t if x is a positive number
    (procedure? p) return #t if p is a procedure
    (quotient x y ) return the integer quotient of x divided by y
    (rational? ) UNIMPLEMENTED
    (read )
    (read-char )
    (real? ) UNIMPLEMENTED
    (remainder x y) return the remainder of x divided by y
    (reverse L) reverse the list L
    (round x) return the nearest integer to the number x
    (scheme-report-environment )
    (set-car! )
    (set-cdr! )
    (sin x) the sine of x
    (sqrt x) the square root of x
    (string )
    (string->list )
    (string->number )
    (string->symbol )
    (string-append a b c ... d) combine the strings a, b, ..., d into a single new string
    (string-ci<=? )
    (string-ci )
    (string-ci=? )
    (string-ci>=? )
    (string-ci>? )
    (string-copy )
    (string-fill! )
    (string-length x) return the number of characters in the string x
    (string-ref )
    (string-set! )
    (string<=? )
    (string )
    (string=? )
    (string>=? )
    (string>? )
    (string? )
    (substring s i j ) return the substring of s that starts at position i and ends right before position j, where 0 is the first position in the string.
    (symbol->string )
    (symbol? s) return #t if s is a symbol
    (tan x) tangent of x
    (truncate x) remove the fractional part of the decimal x to get an integer
    (vector )
    (vector->list )
    (vector-fill! )
    (vector-length )
    (vector-ref )
    (vector-set! )
    (vector? )
    (write )
    (write-char )
    (zero? z) return #t if z equals 0 

**** Modules

Originally implemented by Derek Upham (derek.upham at ontain.com).
Modified by Tim Hickey (5/04) to use the "use-module" syntax.

Modules are implemented using the facilty for creating and
manipulating multiple independent JScheme instances. Each such
instance constains a DynamicEnvironment which is a set of bindings of
symbols to values.

Any scheme file can be loaded as a module. The key idea is that when a
file is loaded as a module it is first loaded into its own Jscheme
instance (with a new DynamicEnvironment). Then the original
environment is extended by importing some or all of the bindings from
the module (possibly with a prefix).

The environments created when loading a module are cached so that
modules are only loaded once. Moreover, a module can recursively use
submodules, but modules can not depend on each other recursively as
this will cause an infinite loop.

The syntax for using modules is as follows:

(use-module MODULE)
(use-module MODULE SPECIFIER)
(use-module MODULE SPECIFIER SYMBOLS)
(use-module MODULE SPECIFIER SYMBOLS PREFIX)

where

MODULE is a either a filename, or a URL, or the name of a compiled Scheme class

- SPECIFIER is one of the following: 'import-procedures 'import-macros
  'import and it specifies whether to import procedures, macros, or
  both. The default value is 'import.

- SYMBOLS is either the symbol 'all or is a list of symbols. The
  default value is 'all In the former case, all symbols defined in the
  module are imported to the current environment; in the latter case,
  only those symbols in the list are imported

- PREFIX is a string which is prepended to each imported symbol from
  the module before that value is put into the current
  environment. The default value is the empty string "".

***** Examples

The following are all equivalent:

(use-module "elf/basic.scm")
(use-module "elf/basic.scm" 'import)
(use-module "elf/basic.scm" 'import 'all)
(use-module "elf/basic.scm" 'import 'all "")

The following examples show how to get more control over what is
imported. You can import only procedures, or only macros, or import
some subset of the procedure or macros.

> (use-module "elf/basic.scm" 'import-procedures 'all)
> (print "string")

> (use-module "elf/basic.scm" 'import-procedures '(describe print))
> (describe print)

> (use-module "elf/basic.scm" 'import-macros 'all)
> (dotimes (x 5) (print x))

> (use-module "elf/basic.scm" 'import-macros '(dotimes))
> (dotimes (x 5) (display x))

>(use-module "elf/basic.scm" 'import '(describe print dotimes))
> (dotimes (x 5) (print x))

Finally, you can add arbitrary prefixes to the symbols that are
imported, but prefixes are never applied to the macros.

> (use-module "elf/basic.scm" 'import-procedures '(describe print) "elf:")
> (elf:describe 5)

> (use-module "elf/basic.scm" 'import-procedures '(describe print) "elf-")
> (elf-describe (java.awt.Button. "hi"))

> (use-module "elf/basic.scm" 'import '(describe print dotimes) "elf:")
> (dotimes (x 5) (elf:print x))

***** Explanations

    (use-module "elf/basic.scm") is equivalent to
    (use-module "elf/basic.scm" 'import 'all "")

This creates a new JScheme instance js and loads elf/basic.scm into
js. Then it takes each of the symbols defined in the js environment
and transfers those bindings verbatim to the current
environment. Note: any closures imported into the current environment
will point to the js environment. Hence, we can freely modify the
values of the primitives (set! car cdr) without changing the behavior
of the procedures and macros imported from elf/basic.scm.

    (use-module "elf/basic.scm" 'import-procedures) is equivalent to
    (use-module "elf/basic.scm" 'import-procedures 'all "")

This does the same as above, but only imports the procedures, not the
macros.

    (use-module "elf/basic.scm" 'import-procedures '(describe apropos)) is equivalent to
    (use-module "elf/basic.scm" 'import-procedures '(describe apropos) "")

This does the same as the first example, but only imports two things,
the bindings for the describe and apropos procedures.

    (use-module "elf/basic.scm" 'import-macros '(dotimes)) is equivalent to
    (use-module "elf/basic.scm" 'import-macros '(dotimes) "")

This does the same as the first example, but only imports the binding
for the dotimes macro.

    (use-module "elf/basic.scm" 'import '(describe apropos dotimes))

This does the same as the first example, but only imports three
things, the bindings for the describe and apropos procedures and the
binding for the dotimes macro.

    (use-module "elf/basic.scm" 'import-procedures '(describe apropos) "elf:")

This does the same as the previous example, but it binds the
describe,apropos values from the js environment to the symbols:

      elf:describe
      elf:apropos

Note that the prefix is not applied to macros. The rationale here is
that macros are changing the syntax of the language, and that
introducing prefixes makes the syntax even more confusing.

    (use-module "elf/basic.scm" 'import-procedures '(describe apropos) "elf-")

This does the same as the previous example, but it binds the
describe,apropos values from the js environment to the symbols:

      elf-describe
      elf-apropos

Note that the prefix is not applied to macros. The rationale here is
that macros are changing the syntax of the language, and that
introducing prefixes makes the syntax even more confusing.

    (use-module "elf/basic.scm" 'import '(describe apropos dotimes) "elf:")

This does the same as the previous example, but it binds the
describe,apropos,dotimes values from the js environment to the
symbols:

      elf:describe
      elf:apropos
      dotimes

Note that the prefix is not applied to macros. The rationale here is
that macros are changing the syntax of the language, and that
introducing prefixes makes the syntax even more confusing.

***** eval and environments

There are three named environments accessible from Jscheme:

- (null-environment) -- which contains no definitions, but does handle
  Javadot notation

- (initial-environment) -- which contains only the Jscheme primitives

- (interaction-environment) -- which is the "current" toplevel
  environment

The eval procedure can be called with any of these three environments
as its second parameter, e.g.

> (eval `(jsint.Op.add 3 4) (null-environment)) 
 7
> (eval '(begin (set! + *) (+ 3 4)) (initial-environment))
 SchemeException:[[ERROR: attempting to alter bindings in locked environment:+ <-- {jsint.Primitive *[0,n]}""]]
> (eval '(begin (set! + *) (+ 3 4)) (interaction-environment))
12
> (+ 3 4)
12

*** JLIB Manual

JLIB is a high-level interface to the Java AWT.

The key idea is to use the flexibility and expressiveness of Scheme to
create a GUI-building library which allows complex GUIs to be built by
evaluating a simple and declarative expression whose structure closely
resembles the structure of the GUI itself.

The JLIB model is based on five fundamental concepts:

- COMPONENTS -- there are a small number of ways to construct basic
  components (buttons, windows, ...)

- LAYOUTS -- there are a small number of ways to layout basic
  components (row, col, table, grid, ...)

- ACTIONS -- there is a simple mechanisms for associating an action to
  a component

- PROPERTIES -- there are easy ways for setting the font and color of
  components

- TAGGING -- there is a simple mechanism for giving names to
  components "in place"

Another key idea is that operations on all components should be as
uniform as possible. For example, there are procedures "readstring"
and "writestring" which allow one to read a "string" from a component,
and write a string onto a component. Thus "writestring" can change the
string on a label, a button, a textfield, a textarea. It can also
change the title of a window or add an item to a choice
component. Likewise, readstring returns the label of a button, the
text in a textarea or textfield, the text of the currently selected
item in a choice, the title of a window, and the text of a label.

Similarly, JLIB is designed so that the component and layout
constructors require a few initial arguments of specified types,
followed by many optional arguments which may apper in any order and
whose types are used to determine their effect.

For example, a font object will change the font of the component, a
color object will change the background color, a Listener object will
add an action listener to the component, a string will generally
become the label of the object.

The current JLIB primitives are listed in the sections below.

**** Components

Components are created using the functions below. The optional
arguments are described in the next section and can be used to set the
color, font, and other properties of the component. The type of the
argument is used to determine how it affect the component.

- (window TITLE arg1 arg2 ...)

- (button STRING arg1 arg2 ...)

- (textfield STRING NUMCOLS arg1 arg2 ...)

- (textarea NUMROWS NUMCOLS arg1 arg2 ...)

- (choice arg1 arg2 ...)

- (label STRING arg1 arg2 ...)

- (canvas W H ...)

- (menubar NAME arg1 arg2 ...)

- (menu NAME arg1 arg2 ...)

- (menuitem NAME arg1 arg2 ...) 

**** Layouts

Tabular layouts:

- (row arg1 arg2 ...)

- (col arg1 arg2 ...)

- (splitrow s1 s2 R1 R2 arg1 ...) creates a box containing two rows whose relative sizes are given by the proportion s1::s2

- (splitcol s1 s2 C1 C2 arg2 ...) creates a box containing two cols whose relative sizes are given by the proportion s1::s2

- (table ROWS COLS arg1 arg2 ...) creates a box consisting of the specified numbers of rows and columns

- (grid NUMROWS NUMCOLS arg1 arg2 ...) creates a table where all cells have the same size 

These layouts all allow some additional arguments which specify how
the components are placed in a cell and how they expand when the cell
is enlarged:

- placement: 'center 'north 'northeast 'east 'southeast ...

- expansion: 'horizontal 'vertical 'both 'none

Border Layout:

- (border arg1 arg2 ...) 

The args can specify properties of the container (e.g. color, font,
etc.) and they can also include the following terms which add up to
five components to specified parts of the layout. When the layout is
resized, the center component expands in both ways, the north and
south components expand horizontally only, and the east and west
expand vertically only. The following positional args must precede the
other args (font/color/etc.)

- (north COMPONENT)

- (south COMPONENT)

- (east COMPONENT)

- (west COMPONENT)

- (center COMPONENT) 

Card Layout

- (cards (card NAME1 COMPONENT) (card NAME2 COMPONENT) ....) -- this creates a COMPONENT with the CardLayout consisting of several NAMEd components. Only one of the cards is visible at a time

- (showcards CARDS NAME) -- this causes the CARDS layout to make the NAMEd card visible. 

**** Arguments to Components and Layouts

Colors -- these set the background color of the component

- standard colors: black, white, red, green, ...

- (color R G B)

- (color 0xRRGGBB) 

Fonts -- these set the font of the component

- (Courier N) (CourierBold N) (CourierItalic N)

- (TimesRoman N) (TimesRomanBold N) (TimesRomanItalic N)

- (Helvetica N) (HelveticaBold N) (HelveticaItalic N)

- (java.awt.Font. NAME STYLE SIZE) 

Actions -- these specify the actions to be carried out when the component receives an action event

- (action (lambda (e) COMMANDS)) 

Size -- (size WIDTH HEIGHT)

- window -- set the size of the window

- textarea -- set the size of the textarea in rows and columns 

Strings

- textarea -- store string in the textarea

- choice -- add the string as one of the choices

- menu -- add the string as a simple menuitem

- menuitem -- set the label of the menuitem to the string 

Components

- for layouts, add the component to the layout 

Tags

- (let ((tag (maketagger))) EXPR) creates a tagger "tag" whose scope is the EXPR
- (tag STRING) -- returns the component which has been tagged with the string
- (tag STRING COMPONENT) -- tags the component with the string and returns the COMPONENT 

Lambdas

- (lambda(C) COMMANDS) -- commands to be carried out on the component "C" when it is being created, for example
- (lambda (C) (.setForeground C blue)) -- sets the foreground color of the component to blue
- (lambda (C) (.hide C)) -- makes C invisible (although it still takes up space in the layout)
- (lambda (C) (display (list "just created " C)) (newline)) -- prints a message when C is created 

**** Actions

Reading/Writing on Components

- (readstring COMPONENT) -- reads the text on a component as a string
- (readexpr COMPONENT) -- reads the text on a component as a Scheme term
- (readexprlist COMPONENT) -- reads the text on a component as a sequence of Scheme terms and returns a list containing those terms
- (writeexpr COMPONENT OBJ) -- convert the object to a string and write on the component
- (writelnexpr COMPONENT OBJ) -- same as above, but add a new line at the end
- (appendexpr COMPONENT OBJ) -- append the stringified object to the text on the component
- (appendlnexpr COMPONENT OBJ) -- same as above, but add a newline at the end 

Other Common Java Actions

- (.hide COMP) (.show COMP) hiding or showing a component (or window)
- (.pack WIN) (.resize WIN) resizing a window
- (.setForeground COMP COLOR) (.setBackground COMP COLOR)
- (.setFont COMP FONT)
- (.addMouseListener COMP (Listener. (lambda(e) (.getX e) (.getY e) ...)))
- (.addMouseMotionListener COMP (Listener. (lambda(e) (.getX e) (.getY e) ...)))
- (.fillRect (.getGraphics g) x y w h)
- (.fillRect (.bufferg$ CANVAS) x y w h) (.repaint CANVAS) -- canvas objects have an associated backbuffer which you can access using (.bufferg$ CANVAS). 

The current JLIB is accessible here and we have a SWING version as
well, which is accessible here To get the most uptodate version you
should download the latest jscheme source from CVS.

*** See also

- Leveraging Libraries in Lightweight Languages: the Jscheme Experience; or, How Bambi snuggles with Godzilla (http://ll2.ai.mit.edu/talks/bbnll2)

** The Scheme Prelude User Manual

*** YASOS: Scheming  with  Objects

There is a saying--attributed to Norman Adams--that "Objects are a
poor man's closures." In this article we discuss what closures are and
how objects and closures are related, show code samples to make these
abstract ideas concrete, and implement a Scheme Object System which
solves the problems we uncover along the way.

**** THE CLASSICAL OBJECT MODEL


Before discussing object oriented programming in Scheme, it pays to
take a look at the classical model so that we have something to
compare with and in order to clarify some of the terminology.  One of
the problems that the OO movement created for itself was the use of
new terms to get away from older concepts and the confusion this has
caused.  So before going further I would like to give some of my own
definitions and a simple operational model.  The model is not strictly
correct as most compiled systems use numerous short cuts and special
optimization tricks, but it is close enough for most practical
purposes and has been used to implement OO programming in imperative
languages.

An object "instance" consists of local (encapsulated) state and a
reference to shared code which operates on its state.  The easy way to
think of this is as a C struct or Pascal record which has one field
reserved for a pointer to its shared code environment and other slots
for its instance variables.  Each procedure in this shared environment
is called a "method." A "class" is code which is can generate
instances (new records) by initializing their fields, including a
pointer to the instance's shared method environment.  The environment
just maps method names to their values (their code).  Each method is a
procedure which takes the record it is operating on as its first,
sometimes hidden, argument.  The first argument is called the
"reciever" and typically aliased to the name "self" within the
procedure's code. 

In order to make code management easy, object oriented systems such as
Actor or Smalltalk wish to deal with code as objects and the way this
is done is by making each class an object instance as well.  In order
to manipulate the class's code, however a "meta-class" is typically
defined and in some cases a meta-meta...  Well, you get the idea.
Many people have spent a great deal of time in theories of how to
"ground" such systems without infinite recursion.  To confuse things
further, many object systems have an object named "object" and a class
object named "class"--so that the class of the "class" object is
`class'. 

By making every data object an instance of the OO system, uniformity
demands that numbers are added, e.g. 1 + 2 by "sending the message" +
to the object 1 with the argument 2.  This has the advantage that + is
polymorphic--it can be applied to any data object.  Unfortunately,
polymorphism also makes optimization hard in that the compiler can no
longer make assumptions about + and may not be able to do constant
folding or inlining. 

The set of methods an object responds to is called a "protocol".
Another way of saying this is that the functions or operations that
are invokeable on an object make up its interface.  More than one
class of object may respond to the same protocol--i.e. many different
types of objects have the same operation names available. 

**** OBJECT BASED MESSAGE PASSING

So how can this "message passing" be implemented with lexical
closures?  And what are these closure things anyway? 

References within a function to variables outside of the local
scope--free references--are resolved by looking them up in the
environment in which the function finds itself.  When a language is
lexically scoped, you see the shape of the environment when you
read--lex--the code.  In Scheme, when a function is created it
remembers the environment in which it was created.  Free names are
looked up in that environment, so the environment is said to be
"closed over" when the function is created.  Hence the term "closure."

An example may help here:

    (define (CURRIED-ADD x) (lambda (y) (+ x y))
    (define ADD8 (curried-add 8))
    (add8 3) ; => 11

When add8 is applied to its argument, we are doing ((lambda (y) (+ x
y)) 3).

The function add8 remembers that X has the value 8.  It gets the value
Y when it is applied to 3.  It finds that + is the addition function.
So (add8 3) evaluates to 11.

(define ADD5 (curried-add 5)) makes a new function which shares the
curried-add code (lambda (y) (+ x y)), but remembers that in its
closed over environment, X has the value 5.

Now that we have a way to create data objects, closures, which share
code but have different data, we just need a "dispatching function" to
which we can pass the symbols we will use for messages:

    (define (MAKE-POINT the-x the-y)
      (lambda (message)
        (case message
          ((x)  (lambda () the-x)) ;; return a function which returns the answer
          ((y)  (lambda () the-y))
          ((set-x!) 
           (lambda (new-value)
             (set! the-x new-value)  ;; do the assignment
             the-x))                ;; return the new value
          ((set-y!) 
           (lambda (new-value)
             (set! the-y new-value)
             the-y))
          (else (error "POINT: Unknown message ->" message)))))

    (define p1 (make-point 132 75))

    (define p2 (make-point 132 57))

    ((p1 'x)); => 132

    ((p1 'set-x!) 5) ; => 5

We can even change the message passing style to function calling
style:

    (define (x obj) ((obj 'x))
    (define (set-x! obj new-val) ((obj 'set-x!) new-val))
    (set-x! p1 12) 	; => 12 
    (x p1) 		    ; => 12
    (x p2)		    ; => 132
    ;; p1 and p2 share code but have different local data

Using Scheme's lexical scoping, we can also define make-point as:

(define (MAKE-POINT the-x the-y)
  (define (get-x) the-x)	;; a "method"
  (define (get-y) the-y)
  (define (set-x! new-x) 
    (set! the-x new-x)
    the-x)
  (define (set-y! new-y) 
    (set! the-y new-y)
    the-y)
  (define (self message)
    (case message
      ((x)   	  get-x) ;; return the local function
      ((y)  	  get-y)
      ((set-x!) set-x!)
      ((set-y!) set-y!)
      (else (error "POINT: Unknown message ->" message))))
  self)	 ;; the return value of make-point is the dispatch function

**** ADDING INHERITANCE

"Inheritance" means that one object may be specialized by adding to
and/or shadowing another's behavior.  It is said that "object based"
programming together with inheritance is "object oriented" programming.
How can we add inheritance to the above picture?  By delegating to
another object! 

(define (MAKE-POINT-3D a b the-z)
  (let ( (point (make-point a b)))

   (define (get-z) the-z)

   (define (set-z! new-value)
      (set! the-z new-value)
      the-z)

   (define (self message)
     (case message
         ((z) 		get-z)
         ((set-z!) 	set-z!)
         (else (point message))))

  self
)

(define p3 (make-point-3d 12 34 217))

(x p3)		-> 12

(z p3)		-> 217

(set-x! p3 12)	-> 12

(set-x! p2 12)	-> 12

(set-z! p3 14)	-> 14

Note that in this style, we are not required to have a single distinguished
base object, "object"--although we may do so if we wish.

**** WHAT IS WRONG WITH THE ABOVE PICTURE?

While the direct strategy above is perfectly adequate for OO
programming, there are a couple of rough spots.  For example, how can
we tell which functions are points and which are not?  We can define a
POINT?  predicate, but not all Scheme data objects will take a 'point?
message.  Most will generate error messages, but some will just "do
the wrong thing."

(define (POINT? obj) (and (procedure? obj) (obj 'point?)))

(point? list) 	-> (point?)  ;; a list with the symbol 'point?

We want a system in which all objects participate and in which we can
mix styles.  Building dispatch functions is repetitive and can
certainly be automated--and let's throw in multiple inheritance while
we are at it.  Also, it is generally a good design principle to
separate interface from implementation, so we will. 

**** ONE SET OF SOLUTIONS

The following is one of a large number of possible implementations.
Most Scheme programmers I know have written at least one object system
and some have written several.  Let's first look at the interface, then
how it is used, then how it was implemented.

In order to know what data objects are "instances", we have a
predicate, INSTANCE?, which takes a single argument and answers #t or
#f.  

For each kind of object is also useful to have a predicate, so we
define a predicate maker: (DEFINE-PREDICATE <opname?>) which by default
answers #f.  

To define operations which operate on any data, we need a default
behavior for data objects which don't handle the operation:
(DEFINE-OPERATION (opname self arg ...) default-body).  If
we don't supply a default-behavior, the default default-behavior
is to generate an error.

We certainly need to return values which are instances of our object
system: (OBJECT operation...), where an operation has the form:
((opname self arg ...) body).  There is also a LET-like form for
multiple inheritance:

    (OBJECT-WITH-ANCESTORS ((ancestor1 init1) ...)
                           operation ...)

In the case of multiple inherited operations with the same identity,
the operation used is the one found in the first ancestor in the
ancestor list.

And finally, there is the "send to super" problem, where we want to
operate as an ancestor, but maintain our own self identity {more on
this below}: (OPERATE-AS component operation composite arg ...).

Note that in this system, code which creates instances is just code,
so there there is no need to define "classes" and no meta-<anything>!

**** EXAMPLES

O.K., let's see how this fits together.  First, another look at
points. (See LISTING: Points revisited.)

(define P2 (make-point 123 32131))
(define P3 (make-point-3d 32 121 3232))
(size "a string")	-> 8
(size p2)		-> 2
(size p3)		-> 3
(point? p2)		-> #t
(point? p3)		-> #t
(point? "a string")	-> #f
(x p2)			-> 123
(x p3)			-> 32
(x "a string")		-> ERROR: Operation not handled: x "a string"
(print p2 #t)		#<point: 123 32131>
(print p3 #t)   	#<3D-point: 32 121 3232>
(print "a string" #t) 	"a string"

Things to notice:

- Interface is separate from implementation

- All objects participate

- Inheritance is simplified

- Print unifies treatment of objects--each decides how it is to be
  displayed

- Default behaviors are useful
  
Now lets look at a more interesting example, a simplified savings
account with history and passwords.

***** LISTING: Bank accounts

(define FRED  (make-person "Fred" 19 "573-19-4279" #xFadeCafe))
(define SALLY
  (make-account "Sally" 26 "629-26-9742" #xFeedBabe 263 bank-password))

(print fred #t)		#<Person: Fred age: 19>
(print sally #t)	#<Bank-Customer Sally>
(person? sally)		-> #t
(bank-account? sally)	-> #t
(ssn fred  #xFadeCafe)	-> "573-19-4279"
(ssn sally #xFeedBabe)	-> "629-26-9742"
(add sally 130) 	New balance: $393
(add sally 55)		New balance: $448

; the bank can act in Sally's behalf
(get-account-history sally bank-password)  		--> (448 393 263)
(withdraw sally 100 (get-pin sally bank-password))	New balance: $348
(get-account-history sally bank-password)          	--> (348 448 393 263)

;; Fred forgets
(ssn fred 'bogus)	Bad password: bogus	;; Fred gets another chance

;; Sally forgets
(ssn sally 'bogus)	CALL THE POLICE!!	;; A more serious result..

Now we see the reason we need OPERATE-AS.  The when the bank-account
object delegates the SSN operation to its ancestor, person, SELF is
bound to the bank-account object--not the person object.  This means
that while the code for SSN is inherited from person, the BAD-PASSWORD
operation of the bank-account is used.

This is an important behavior to have in an object system.  If there
were no OPERATE-AS, code would have to be duplicated in order to
implement the stricter form of BAD-PASSWORD.  With OPERATE-AS, we can
safely share code while keeping operations localized within the
inheritance hierarchy.

**** OUR IMPLEMENTATION

Given the sophisticated behavior of our object system, the
implementation is surprisingly small.

(See LISTING: yasos)

Unlike some other languages, Scheme does not have a standard way of
defining opaque types.  In order to distinguish data objects which are
instances of our object system, we just uniquely tag a closure.  As we
are only introducing one new datatype it is not much work to hide this
by rewriting Scheme's WRITE and DISPLAY routines. 

In order to allow lexical scoping of objects and operations, the
values of operations, rather than their names, are used in the
dispatch functions created for objects.  Those of you who have used
languages such as Smalltalk or Actor may have been bitten by the
inadvertant name collisions in the single, global environment.

Note that there are no global tables.  A general rule of thumb is that
for less than 100 elements, linear search beats hashing.  While we can
speed up operation dispatch by some simple caching, the general
performance for this system will be pretty good up through moderately
large systems.  Also, we can optimize the implementation with no
change to the interface.  If our systems start getting too slow, it's
time to smarten the compiler.

**** HOW THIS COMPARES TO THE CLASSICAL MODEL

It is time to compare this implementation to the model given at the
beginning of this article.

One thing you may notice right away is the power of closures.  The
object system is small and simpler than the class model.  There are no
grounding problems.  No "Meta".  I find it interesting that
Whitewater's Actor 4.0 implements code sharing between classes (which
they call multiple inheritance) in an attempt to get more of the
benefits that closures provide directly.

The Scheme solution is also more general.  It keeps lexical scoping,
and one can freely mix OO with functional & imperative styles.

Programming Environment work still has to be done for code management
& debugging (e.g. doing an object inspector), but OO helps here just
as in other OO systems.

Separating the interface from the implementation is a better software
engineering solution than the classical model.  We can define our
"protocols" independently of their implementation.  This helps us hide
our implementation.  One might think that object oriented programming
in general would solve the problems here, but this has not been the
case because people still use inheritance to share code rather than
just to share abstractions.  An example of this is the complex
behavior of Smalltalk dictionaries because they inherit the
implementation of Sets.  While code sharing is a benefit of OO it is
still considered bad form when your code breaks because of a change in
the implementation of an inherited abstraction.

Finally, I would like to point out that one can implement other OO
models directly in Scheme, including smaller, simpler ones!  You can
also implement the classical model (e.g. see D. Friedman, M. Wand, &
C. Haynes: _Essentials of Programming Languages_, McGraw Hill, 1992).

Remember, your programming language should be part of the solution,
not part of your problems.  Scheme for success!

**** LISTING: Points revisited

;;--------------------- general operations ---------------------

(define-operation (PRINT obj port) 
  (format port  ;; *** see LISTING: format ***
          ;; if an instance does not have a PRINT operation..
          (if (instance? obj) "#<INSTANCE>" "~s") 
          obj))

(define-operation (SIZE obj)
  ;; default behavior
  (cond   
    ((vector? obj) (vector-length obj))
    ((list?   obj) (length obj))
    ((pair?   obj) 2)
    ((string? obj) (string-length obj))
    ((char?   obj) 1)
    (else 
      (error "Operation not supported: size" obj))
))


;;----------------
;; point interface
;;----------------

(define-predicate POINT?)  ;; answers #f (false) by default
(define-operation (X obj))
(define-operation (Y obj))
(define-operation (SET-X! obj new-x))
(define-operation (SET-Y! obj new-y))


;;---------------------
;; point implementation
;;---------------------

(define (MAKE-POINT the-x the-y)
  (object
     ((POINT? self) #t) ;; yes, this is a point object
     ((X self) the-x)
     ((Y self) the-y)
     ((SET-X! self val)
      (set! the-x val)
      the-x)
     ((SET-Y! self val)
      (set! the-y val)
      the-y)
     ((SIZE self) 2)
     ((PRINT self port)
      (format port "#<point: ~a ~a>" (x self) (y self)))
))

;;-----------------------------
;; 3D point interface additions
;;-----------------------------

(define-operation (Z obj))
(define-operation (SET-Z! obj new-z))


;;------------------------
;; 3D point implementation
;;------------------------

(define (MAKE-POINT-3D the-x the-y the-z)
   (object-with-ancestors ( (a-point (make-point the-x the-y)))
      ((Z self) the-z)
      ((SET-Z! self val) (set! the-z val) the-z)
      ;; override inherited SIZE and PRINT operations
      ((SIZE self) 3)
      ((PRINT self port)
       (format port "#<3D-point: ~a ~a ~a>" (x self) (y self) (z self)))
) )

**** LISTING: Bank accounts

;;-----------------
;; person interface
;;-----------------

(define-predicate PERSON?)

(define-operation (NAME obj))
(define-operation (AGE obj))
(define-operation (SET-AGE! obj new-age))
(define-operation (SSN obj password)) ;; Social Security # is protected
(define-operation (NEW-PASSWORD obj old-passwd new-passwd))
(define-operation (BAD-PASSWORD obj bogus-passwd)
  ;; assume internal (design) error
  (error (format #f "Bad Password: ~s given to ~a~%" 
                    bogus-passwd
		    (print obj #f)))
)


;;----------------------
;; person implementation
;;----------------------

(define (MAKE-PERSON a-name an-age a-SSN the-password)
  (object
    ((PERSON? self) #t)
    ((NAME self) a-name)
    ((AGE self) an-age)
    ((SET-AGE! self val) (set! an-age val) an-age)
    ((SSN self password)
     (if (equal? password the-password)
         a-SSN
	 (bad-password self password))
   )
    ((NEW-PASSWORD obj old-passwd new-passwd)
     (cond
       ((equal? old-passwd the-password) (set! the-password new-passwd) self)
       (else (bad-password self old-passwd))
   ))
    ((BAD-PASSWORD self bogus-passwd)
     (format #t "Bad password: ~s~%" bogus-passwd))  ;; let user recover
    ((PRINT self port)
	 (format port "#<Person: ~a age: ~a>" (name self) (age self)))
))

;;--------------------------------------------
;; account-history and bank-account interfaces
;;--------------------------------------------

(define-predicate BANK-ACCOUNT?)

(define-operation (CURRENT-BALANCE account pin))
(define-operation (ADD obj amount))
(define-operation (WITHDRAW obj amount pin))
(define-operation (GET-PIN account master-password))
(define-operation (GET-ACCOUNT-HISTORY account master-password))

;;-------------------------------
;; account-history implementation
;;-------------------------------
;; put access to bank database and report generation here

(define (MAKE-ACCOUNT-HISTORY initial-balance a-PIN master-password)
  ;; history is a simple list of balances -- no transaction times
  (letrec ( (history (list initial-balance)) 
            (balance (lambda () (car history))) ; balance is a function
            (remember 
              (lambda (datum) (set! history (cons datum history))))
         )
    (object
      ((BANK-ACCOUNT? self) #t)
      ((ADD self amount) ;; bank will accept money without a password
       (remember (+ amount (balance)))
       ;; print new balance
       (format #t "New balance: $~a~%" (balance)) 
     )
      ((WITHDRAW self amount pin)
       (cond
          ((not (equal? pin a-pin)) (bad-password self pin))
	  ((< (- (balance) amount) 0)
	   (format #t 
	          "No overdraft~% Can't withdraw more than you have: $~a~%"
		  (balance))
         )
	  (else
	    (remember (- (balance) amount))
            (format #t "New balance: $~a~%" (balance)))
     ))
      ((CURRENT-BALANCE self password)
       (if (or (eq? password master-password) (equal? password a-pin))
           (format #t "Your Balance is $~a~%" (balance))
	   (bad-password self password)
     )
      ;; only bank has access to account history
      ((GET-ACCOUNT-HISTORY account password) 
       (if (eq? password master-password)
           history
	   (bad-password self password)
     ))
)))

;;----------------------------
;; bank-account implementation
;;----------------------------

(define (MAKE-ACCOUNT a-name an-age a-SSN a-PIN initial-balance master-password)
  (object-with-ancestors 
   ((customer (make-person a-name an-age a-SSN a-PIN))
     (account  (make-account-history initial-balance a-PIN master-password)))
   ((GET-PIN self password)
    (if (eq? password master-password)
        a-PIN
      (bad-password self password)
     ))
   ((GET-ACCOUNT-HISTORY self password)
    (operate-as account get-account-history self password)
   )
   ;; our bank is very conservative...
   ((BAD-PASSWORD self bogus-passwd)
    (format #t "~%CALL THE POLICE!!~%")  
   )
   ;; protect the customer as well
   ((SSN self password) 
    (operate-as customer SSN self password))
   ((PRINT self port)
    (format port "#<Bank-Customer ~a>" (name self)))))

*** pregexp: Portable Regular Expressions for Scheme

by Dorai Sitaram <http://ds26gte.github.com>

`pregexp.scm` is a portable library for *regular expressions* (aka *regexps* or *regexes*) that runs in any Scheme that complies with R4RS, R5RS or R6RS.  It provides regular expressions modeled on Perl's, and includes such powerful directives as:

- numeric and nongreedy quantifiers
- capturing and non-capturing clustering
- POSIX character classes
- selective case- and space-insensitivity
- backreferences
- alternation
- backtrack pruning
- positive and negative lookahead and lookbehind
- in addition to the more basic directives familiar to all regexp users

To use, simply load the file `pregexp.scm` into your Scheme.

**** Introduction

A *regexp* is a string that describes a pattern.  A regexp matcher tries to *match* this pattern against (a portion of) another string, which we will call the *text string*.  The text string is treated as raw text and not as a pattern.

Most of the characters in a regexp pattern are meant to match occurrences of themselves in the text string. Thus, the pattern `"abc"` matches a string that contains the characters `a`, `b`, `c` in succession.

In the regexp pattern, some characters  act as *metacharacters*, and some character sequences act as *metasequences*.  That is, they specify something other than their literal selves.  For example, in the pattern `"a.c"`, the characters `a` and `c` do stand for themselves but the *metacharacter* `.` can match *any* character (other than newline).  Therefore, the pattern `"a.c"` matches an `a`, followed by *any* character, followed by a `c`.

If we needed to match the character `.` itself, we *escape* it, ie, precede it with a backslash (`\`).  The character sequence `\.` is thus a *metasequence*, since it doesn't match itself but rather just `.`.

So, to match `a` followed by a literal `.` followed by `c`, we use the regexp pattern `"a\\.c"`.

The double backslash is an artifact of Scheme strings, not the regexp pattern itself.  When we want a literal backslash inside a Scheme string, we must escape it so that it shows up in the string at all. Scheme strings use backslash as the escape character, so we end up with two backslashes --- one Scheme-string backslash to escape the regexp backslash, which then escapes the dot.  Another character that would need escaping inside a Scheme string is `"`. Another example of a metasequence is `\t`, which is a readable way to represent the tab character.

We will call the string representation of a regexp the *U-regexp*, where *U* can be taken to mean *Unix-style* or *universal*, because this notation for regexps is universally familiar.  Our implementation uses an intermediate tree-like representation called the *S-regexp*, where *S* can stand for *Scheme*, *symbolic*, or *s-expression*.  S-regexps are more verbose and less readable than U-regexps, but they are much easier for Scheme's recursive procedures to navigate.

**** Regexp procedures provided by `pregexp.scm`

`pregexp.scm` provides the following procedures:

- `pregexp`
- `pregexp-match-positions`
- `pregexp-match`
- `pregexp-split`
- `pregexp-replace`
- `pregexp-replace*`
- `pregexp-quote`

All the identifiers introduced by `pregexp.scm` have the prefix `pregexp-`, so they are unlikely to clash with other names in Scheme, including those of any natively provided regexp operators.

***** `pregexp`

The procedure `pregexp` takes
a U-regexp, which is a string, and returns
an S-regexp, which is a tree.


    (pregexp "c.r")
    => (:sub (:or (:seq #\c :any #\r)))

There is rarely any need to look at the S-regexps returned by `pregexp`.

***** `pregexp-match-positions`

The procedure `pregexp-match-positions` takes
a
regexp pattern and a text string, and returns a *match* if the regexp *matches* (some part of) the text string.

The regexp may be either a U- or an S-regexp.
(`pregexp-match-positions` will internally compile a
U-regexp to an S-regexp before proceeding with the
matching.  If you find yourself calling
`pregexp-match-positions` repeatedly with the same
U-regexp, it may be advisable to explicitly convert the
latter into an S-regexp once beforehand, using
`pregexp`, to save needless recompilation.)

`pregexp-match-positions` returns `#f` if the regexp did not
match the string; and a list of *index pairs* if it
did match.  Eg,


    (pregexp-match-positions "brain" "bird")
    => #f

    (pregexp-match-positions "needle" "hay needle stack")
    => ((4 . 10))

In the second example, the integers 4 and 10 identify
the substring that was matched. 4 is the starting
(inclusive) index and 10 the ending (exclusive) index of
the matching substring.


    (substring "hay needle stack" 4 10)
    => "needle"

Here, `pregexp-match-positions`'s return list contains only
one index pair, and that pair represents the entire
substring matched by the regexp.  When we discuss
subpatterns later, we will see how a single match
operation can yield a list of *submatches*.

`pregexp-match-positions` takes optional third
and fourth arguments that specify the indices of
the text string within which the matching should
take place.


    (pregexp-match-positions "needle"
      "his hay needle stack -- my hay needle stack -- her hay needle stack"
      24 43)
    => ((31 . 37))

Note that the returned indices are still reckoned
relative to the full text string.

***** `pregexp-match`

The procedure `pregexp-match` is called
like `pregexp-match-positions`
but instead of returning index pairs it returns the
matching substrings:


    (pregexp-match "brain" "bird")
    => #f

    (pregexp-match "needle" "hay needle stack")
    => ("needle")

`pregexp-match` also takes optional third and
fourth arguments, with the same meaning as does
`pregexp-match-positions`.

***** `pregexp-split`

The procedure `pregexp-split` takes
two arguments, a
regexp pattern and a text string, and returns a list of
substrings of the text string, where the pattern identifies the
delimiter separating the substrings.


    (pregexp-split ":" "/bin:/usr/bin:/usr/bin/X11:/usr/local/bin")
    => ("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")

    (pregexp-split " " "pea soup")
    => ("pea" "soup")

If the first argument can match an empty string, then
the list of all the single-character substrings is returned.


    (pregexp-split "" "smithereens")
    => ("s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s")

To identify one-or-more spaces as the delimiter,
take care to use the regexp `" +"`, not `" *"`.


    (pregexp-split " +" "split pea     soup")
    => ("split" "pea" "soup")

    (pregexp-split " *" "split pea     soup")
    => ("s" "p" "l" "i" "t" "p" "e" "a" "s" "o" "u" "p")

***** `pregexp-replace`

The procedure `pregexp-replace` replaces
the
matched portion of the text string by another
string.  The first argument is the pattern,
the second the text string, and the third
is the *insert string* (string to be inserted).


    (pregexp-replace "te" "liberte" "ty")
    => "liberty"

If the pattern doesn't occur in the text
string, the returned string is identical (`eq?`)
to the text string.

***** `pregexp-replace*`

The procedure `pregexp-replace*` replaces
all
matches in the text string by the insert
string:


    (pregexp-replace* "te" "liberte egalite fraternite" "ty")
    => "liberty egality fratyrnity"

As with `pregexp-replace`, if the pattern doesn't
occur in the text string, the returned string is
identical (`eq?`) to the text string.

***** `pregexp-quote`

The procedure `pregexp-quote` takes
an arbitrary string and returns a U-regexp
(string) that precisely represents it.  In particular,
characters in the input string that could serve as
regexp metacharacters are escaped with a
backslash, so that they safely match only themselves.


    (pregexp-quote "cons")
    => "cons"

    (pregexp-quote "list?")
    => "list\\?"

`pregexp-quote` is useful when building a composite
regexp from a mix of regexp strings and verbatim strings.

**** The regexp pattern language

Here is a complete description of the regexp pattern
language recognized by the `pregexp` procedures.

***** Basic assertions

The *assertions* `^` and `$` identify the
beginning and the end of the text string respectively.
They ensure that their adjoining regexps match at
one or other end of the text string.
Examples:


    (pregexp-match-positions "^contact" "first contact")
    => #f

The regexp fails to match because `contact` does not
occur at the beginning of the text string.


    (pregexp-match-positions "laugh$" "laugh laugh laugh laugh")
    => ((18 . 23))

The regexp matches the *last* `laugh`.

The metasequence `\b` asserts that
a *word boundary* exists.


    (pregexp-match-positions "yack\\b" "yackety yack")
    => ((8 . 12))

The `yack` in `yackety` doesn't end at a word
boundary so it isn't matched.  The second `yack` does
and is.

The metasequence `\B` has the opposite effect
to `\b`.   It asserts that a word boundary
does not exist.


    (pregexp-match-positions "an\\B" "an analysis")
    => ((3 . 5))

The `an` that doesn't end in a word boundary
is matched.

***** Characters and character classes

Typically a character in the regexp matches the same
character in the text string.  Sometimes it is
necessary or convenient to use a regexp
metasequence to refer to a single character.
Thus, metasequences `\n`, `\r`, `\t`, and `\.`
match the newline, return, tab and period characters
respectively.

The *metacharacter* period (`.`) matches
any character other than newline.


    (pregexp-match "p.t" "pet")
    => ("pet")

It also matches `pat`, `pit`, `pot`, `put`,
and `p8t` but not `peat` or `pfffft`.

A *character class* matches any one character from
a set of characters.  A typical format for this
is the *bracketed character class* `[`...`]`,
which matches any one character from the non-empty sequence
of characters enclosed within the brackets.

Requiring
a bracketed character class to be non-empty is not a limitation,
since an
empty character class
can be more easily represented by an empty string.

Thus `"p[aeiou]t"` matches `pat`, `pet`, `pit`,
`pot`, `put` and nothing else.

Inside the brackets, a hyphen (`-`) between two
characters specifies the ascii range between the characters.
Eg, `"ta[b-dgn-p]"` matches `tab`, `tac`, `tad`, *and*
`tag`, *and* `tan`, `tao`, `tap`.

An initial caret (`^`) after the left bracket inverts
the set specified by the rest of the contents, ie, it
specifies the set of characters *other than* those
identified in the brackets.  Eg, `"do[^g]"` matches
all three-character sequences starting with `do`
except `dog`.

Note that the metacharacter `^` inside brackets means
something quite different from what it means outside.
Most other metacharacters (`.`, `*`, `+`, `?`,
etc) cease to be metacharacters when inside brackets,
although you may still escape them for peace of
mind.  `-` is a metacharacter only when it's
inside brackets, and neither the first nor the last character.

Bracketed character classes cannot contain other
bracketed character classes (although they contain
certain other types of character classes --- see
below).  Thus a left bracket (`[`)
inside a bracketed character class doesn't have to be a
metacharacter; it can stand for itself.  Eg,
`"[a[b]"` matches `a`, `[`, and `b`.

Furthermore, since empty bracketed character classes
are disallowed, a right bracket (`]`) immediately occurring
after the opening left bracket
also doesn't need to be a metacharacter.  Eg,
`"[]ab]"` matches `]`, `a`, and `b`.

****** Some frequently used character
classes

Some standard character classes can be conveniently
represented as metasequences instead of as explicit
bracketed expressions.  `\d` matches a  digit
(`[0-9]`); `\s` matches a whitespace character; and
`\w` matches a character that could be part of a
"word".

Following regexp custom, we identify "word" characters as `[A-Za-z0-9_]`, although these are too restrictive for what a Schemer might consider a "word".

The upper-case versions of these metasequences stand
for the inversions of the corresponding character
classes.  Thus `\D` matches a non-digit, `\S` a
non-whitespace character, and `\W` a
non-"word" character.

Remember to include a double backslash when putting
these metasequences in a Scheme string:


    (pregexp-match "\\d\\d"
      "0 dear, 1 have 2 read catch 22 before 9")
    => ("22")

These character classes can be used inside
a bracketed expression.  Eg,
`"[a-z\\d]"` matches a lower-case letter
or a digit.

****** POSIX character classes

A *POSIX character class* is a special metasequence of the form `[:...:]` that can be used only inside a bracketed expression.  The POSIX classes supported are:

- `[:alnum:]`: letters and digits
- `[:alpha:]`: letters
- `[:algor:]`: the letters `c`, `h`, `a` and `d`
- `[:ascii:]`: 7-bit ascii characters
- `[:blank:]`: widthful whitespace, ie, space and tab
- `[:cntrl:]`: "control" characters, viz, those with code `<` 32
- `[:digit:]`: digits, same as `\d`
- `[:graph:]`: characters that use ink
- `[:lower:]`: lower-case letters
- `[:print:]`: ink-users plus widthful whitespace
- `[:space:]`: whitespace, same as `\s`
- `[:upper:]`: upper-case letters
- `[:word:]`: letters, digits, and underscore, same as `\w`
- `[:xdigit:]`: hex digits

For example, the regexp  `"[[:alpha:]_]"`
matches a letter or underscore.


    (pregexp-match "[[:alpha:]_]" "--x--")
    => ("x")

    (pregexp-match "[[:alpha:]_]" "--_--")
    => ("_")

    (pregexp-match "[[:alpha:]_]" "--:--")
    => #f

The POSIX class notation is valid *only* inside a
bracketed expression.  For instance, `[:alpha:]`,
when not inside a bracketed expression, will *not*
be read as the letter class.
Rather it is (from previous principles) the character
class containing the characters `:`, `a`, `l`,
`p`, `h`.


    (pregexp-match "[:alpha:]" "--a--")
    => ("a")

    (pregexp-match "[:alpha:]" "--_--")
    => #f

By placing a caret (`^`) immediately after
`[:`, you get the inversion of that POSIX
character class.  Thus, `[:^alpha]`
is the class containing all characters
except the letters.

***** Quantifiers

The *quantifiers* `*`, `+`, and
`?` match respectively: zero or more, one or more,
and zero or one instances of the preceding subpattern.


    (pregexp-match-positions "c[ad]*r" "cadaddadddr")
    => ((0 . 11))
    (pregexp-match-positions "c[ad]*r" "cr")
    => ((0 . 2))

    (pregexp-match-positions "c[ad]+r" "cadaddadddr")
    => ((0 . 11))
    (pregexp-match-positions "c[ad]+r" "cr")
    => #f

    (pregexp-match-positions "c[ad]?r" "cadaddadddr")
    => #f
    (pregexp-match-positions "c[ad]?r" "cr")
    => ((0 . 2))
    (pregexp-match-positions "c[ad]?r" "car")
    => ((0 . 3))

****** Numeric quantifiers

You can use braces to specify much finer-tuned
quantification than is possible with `*`, `+`, `?`.

The quantifier `{m}` matches *exactly* `m`
instances of the preceding *subpattern*.  `m`
must be a nonnegative integer.

The quantifier `{m,n}` matches at least `m`
and at most `n` instances.  `m` and
`n` are nonnegative integers with `m <=
n`.  You may omit either or both numbers, in which case
`m` defaults to 0 and `n` to
infinity.

It is evident that `+` and `?` are abbreviations
for `{1,}` and `{0,1}` respectively.
`*` abbreviates `{,}`, which is the same
as `{0,}`.


    (pregexp-match "[aeiou]{3`" "vacuous")
    => ("uou")

    (pregexp-match "[aeiou]{3}" "evolve")
    => #f

    (pregexp-match "[aeiou]{2,3}" "evolve")
    => #f

    (pregexp-match "[aeiou]{2,3}" "zeugma")
    => ("eu")

****** Non-greedy quantifiers

The quantifiers described above are *greedy*, ie,
they match the  maximal number of instances that would
still lead to an overall match for the full pattern.

(pregexp-match "<.*>" "<tag1> <tag2> <tag3>")
=> ("<tag1> <tag2> <tag3>")


To make these quantifiers *non-greedy*, append
a `?` to them.  Non-greedy quantifiers match
the minimal number of instances needed to ensure an
overall match.

    (pregexp-match "<.*?>" "<tag1> <tag2> <tag3>")
    => ("<tag1>")

The non-greedy quantifiers are respectively: `*?`, `+?`, `??`, `{m?}`, `{m,n?}`. Note the two uses of the metacharacter `?`.

***** Clusters

Clustering, ie, enclosure within parens `(`...`)`, identifies the enclosed *subpattern* as a single entity.  It causes the matcher to *capture* the *submatch*, or the portion of the string matching the subpattern, in addition to the overall match.


    (pregexp-match "([a-z]+) ([0-9]+), ([0-9]+)" "jan 1, 1970")
    => ("jan 1, 1970" "jan" "1" "1970")

Clustering also causes a following quantifier to treat
the entire enclosed subpattern as an entity.


    (pregexp-match "(poo)*" "poo poo platter")
    => ("poo poo " "poo ")

The number of submatches returned is always equal
to the number of subpatterns specified in the
regexp, even if a particular subpattern happens
to match more than one substring or no substring
at all.


    (pregexp-match "([a-z ]+;)*" "lather; rinse; repeat;")
    => ("lather; rinse; repeat;" " repeat;")

Here the `*`-quantified subpattern matches three
times, but it is the last submatch that is returned.

It is also possible for a quantified subpattern to
fail to match, even if the overall pattern matches.
In such cases, the failing submatch is represented
by `#f`.


    (define date-re
      ;match `month year' or `month day, year'.
      ;subpattern matches day, if present
      (pregexp "([a-z]+) +([0-9]+,)? *([0-9]+)"))

    (pregexp-match date-re "jan 1, 1970")
    => ("jan 1, 1970" "jan" "1," "1970")

    (pregexp-match date-re "jan 1970")
    => ("jan 1970" "jan" #f "1970")

****** Backreferences

Submatches can be used in the insert string argument of
the procedures `pregexp-replace` and
`pregexp-replace*`.  The insert string can use `\n`
as a *backreference* to refer back to the *n*th
submatch, ie, the substring that matched the *n*th
subpattern.   `\0` refers to the entire match,
and it can also be specified as `\&`.


    (pregexp-replace "_(.+?)_"
      "the _nina_, the _pinta_, and the _santa maria_"
      "*\\1*")
    => "the *nina*, the _pinta_, and the _santa maria_"

    (pregexp-replace* "_(.+?)_"
      "the _nina_, the _pinta_, and the _santa maria_"
      "*\\1*")
    => "the *nina*, the *pinta*, and the *santa maria*"

    ;recall: \S stands for non-whitespace character

    (pregexp-replace "(\\S+) (\\S+) (\\S+)"
      "eat to live"
      "\\3 \\2 \\1")
    => "live to eat"

Use `\\` in the insert string to specify a literal
backslash.  Also, `\$` stands for an empty string,
and is useful for separating a backreference `\n`
from an immediately following number.

Backreferences can also be used within the regexp
pattern to refer back to an already matched subpattern
in the pattern.  `\n` stands for an exact repeat
of the *n*th submatch.\f{\ifx\newenvironment\PLAINTEX
`\0`\else
{\tt\\0}\fi
, which is useful in
an insert string, makes no  sense within the regexp
pattern, because the entire regexp has not matched yet
that you could refer back to it.}


    (pregexp-match "([a-z]+) and \\1"
      "billions and billions")
    => ("billions and billions" "billions")

Note that the backreference is not simply a repeat
of the previous subpattern.  Rather it is a repeat of
the particular  substring already matched by the
subpattern.

In the above example, the backreference can only match
`billions`.  It will not match `millions`, even
though the subpattern it harks back to --- `([a-z]+)`
---  would have had no problem doing so:


    (pregexp-match "([a-z]+) and \\1"
      "billions and millions")
    => #f

The following corrects doubled words:


    (pregexp-replace* "(\\S+) \\1"
      "now is the the time for all good men to to come to the aid of of the party"
      "\\1")
    => "now is the time for all good men to come to the aid of the party"

The following marks all immediately repeating patterns
in a number string:

    (pregexp-replace* "(\\d+)\\1"
      "123340983242432420980980234"
      "{\\1,\\1`")
    => "12{3,3}40983{24,24}3242{098,098}0234"

****** Non-capturing clusters

It is often required to specify a cluster
(typically for quantification) but without triggering
the capture of submatch information.  Such
clusters are called *non-capturing*.  In such cases,
use `(?:` instead of `(` as the cluster opener.  In
the following example, the  non-capturing cluster
eliminates the "directory" portion of a given
pathname, and the capturing cluster  identifies the
basename.

```
(pregexp-match "^(?:[a-z]*/)*([a-z]+)$"
  "/usr/local/bin/mzscheme")
=> ("/usr/local/bin/mzscheme" "mzscheme")
```

****** Cloisters

The location between the `?` and the `:` of a
non-capturing cluster is called a *cloister*.\f{A
useful, if terminally cute, coinage from the abbots of
Perl~\cite{pperl}.}  You can put *modifiers*
there that will cause the enclustered subpattern to be
treated specially.  The modifier `i` causes the
subpattern to match *case-insensitively*:

```
(pregexp-match "(?i:hearth)" "HeartH")
=> ("HeartH")
```

The modifier `x` causes the subpattern to match
space-insensitively, ie, spaces and
comments within the
subpattern are ignored.  Comments are introduced
as usual with a semicolon (`;`) and extend till
the end of the line.  If you need
to include a literal space or semicolon in
a space-insensitized subpattern, escape it
with a backslash.

```
(pregexp-match "(?x: a   lot)" "alot")
=> ("alot")

(pregexp-match "(?x: a  \\  lot)" "a lot")
=> ("a lot")

(pregexp-match "(?x:
   a \\ man  \\; \\   ; ignore
   a \\ plan \\; \\   ; me
   a \\ canal         ; completely
  )"
 "a man; a plan; a canal")
=> ("a man; a plan; a canal")
```

The global variable `*pregexp-comment-char*`
contains the comment character (`#\;`).
For Perl-like comments,

```
(set! *pregexp-comment-char* #\#)
```

You can put more than one modifier in the cloister.

```
(pregexp-match "(?ix:
   a \\ man  \\; \\   ; ignore
   a \\ plan \\; \\   ; me
   a \\ canal         ; completely
  )"
 "A Man; a Plan; a Canal")
=> ("A Man; a Plan; a Canal")
```

A minus sign before a modifier inverts its meaning.
Thus, you can use `-i` and `-x` in a *subcluster* to overturn the insensitivities caused by an
enclosing cluster.

```
(pregexp-match "(?i:the (?-i:TeX)book)"
  "The TeXbook")
=> ("The TeXbook")
```

This regexp will allow any casing for `the`
and `book` but insists that `TeX` not be
differently cased.

***** Alternation
\label{alternation}

You can specify a list of *alternate*
subpatterns by separating them by \p/|/.   The \p/|/
separates subpatterns in the nearest enclosing cluster
(or in the entire pattern string if there are no
enclosing parens).

\q@
(pregexp-match "f(ee|i|o|um)" "a small, final fee")
=> ("fi" "i")

(pregexp-replace* "([yi])s(e[sdr]?|ing|ation)"
   "it is energising to analyse an organisation
   pulsing with noisy organisms"
   "\\1z\\2")
=> "it is energizing to analyze an organization
   pulsing with noisy organisms"
@

Note again that if you wish
to use clustering merely to specify a list of alternate
subpatterns but do not want the submatch, use `(?:`
instead of `(`.

\q@
(pregexp-match "f(?:ee|i|o|um)" "fun for all")
=> ("fo")
@

An important thing to note about alternation is that
the leftmost matching alternate is picked regardless of
its length.  Thus, if one of the alternates is a prefix
of a later alternate, the latter may not have
a chance to match.

\q@
(pregexp-match "call|call-with-current-continuation"
  "call-with-current-continuation")
=> ("call")
@

To allow the longer alternate to have a shot at
matching, place it before the shorter one:

\q@
(pregexp-match "call-with-current-continuation|call"
  "call-with-current-continuation")
=> ("call-with-current-continuation")
@

In any case, an overall match for the entire regexp is
always preferred to an overall nonmatch.  In the
following, the longer alternate still wins, because its
preferred shorter prefix fails to yield an overall
match.

\q@
(pregexp-match "(?:call|call-with-current-continuation) constrained"
  "call-with-current-continuation constrained")
=> ("call-with-current-continuation constrained")
@

***** Backtracking

We've already seen that greedy quantifiers match
the maximal number of times, but the overriding priority
is that the overall match succeed.  Consider

```
(pregexp-match "a*a" "aaaa")
```

The regexp consists of two subregexps,
`a*` followed by `a`.
The subregexp `a*` cannot be allowed to match
all four `a`'s in the text string `"aaaa"`, even though
`*` is a greedy quantifier.  It may match only the first
three, leaving the last one for the second subregexp.
This ensures that the full regexp matches successfully.

The regexp matcher accomplishes this via a process
called *backtracking*.  The matcher
tentatively allows the greedy quantifier
to match all four `a`'s, but then when it becomes
clear that the overall match is in jeopardy, it
backtracks to a less greedy match of *three* `a`'s.  If even this fails, as in the
call

```
(pregexp-match "a*aa" "aaaa")
```

the matcher backtracks even further.  Overall
failure is conceded only when all possible backtracking
has been tried with no success.

Backtracking is not restricted to greedy quantifiers.
Nongreedy quantifiers match as few instances as
possible, and progressively backtrack to more and more
instances in order to attain an overall match.  There
is backtracking in alternation too, as the more
rightward alternates are tried when locally successful
leftward ones fail to yield an overall match.

****** Disabling backtracking

Sometimes it is efficient to disable backtracking.  For
example, we may wish  to  *commit* to a choice, or
we know that trying alternatives is fruitless.  A
nonbacktracking regexp is enclosed in `(?>`...`)`.

```
(pregexp-match "(?>a+)." "aaaa")
=> #f
```

In this call, the subregexp `?>a+` greedily matches
all four `a`'s, and is denied the opportunity to
backpedal.  So the overall match is denied.  The effect
of the regexp is therefore to match one or more `a`'s
followed by something that is definitely non-`a`.

***** Looking ahead and behind

You can have assertions in your pattern that look *ahead* or *behind* to ensure that a subpattern does
or does not occur.   These "look around" assertions are
specified by putting the subpattern checked for in a
cluster whose leading characters are: `?=` (for positive
lookahead), `?!` (negative lookahead), `?<=`
(positive lookbehind), `?<!` (negative lookbehind).
Note that the subpattern in the assertion  does not
generate a match in the final result.  It merely allows
or disallows the rest of the match.

****** Lookahead

Positive lookahead (`?=`) peeks ahead to ensure that
its subpattern *could* match.

```
(pregexp-match-positions "grey(?=hound)"
  "i left my grey socks at the greyhound")
=> ((28 . 32))
```

The regexp `"grey(?=hound)"` matches `grey`, but
only if it is followed by `hound`.  Thus, the first
`grey` in the text string is not matched.

Negative lookahead (`?!`) peeks ahead
to ensure that its subpattern could not possibly match.

```
(pregexp-match-positions "grey(?!hound)"
  "the gray greyhound ate the grey socks")
=> ((27 . 31))
```

The regexp `"grey(?!hound)"` matches `grey`, but
only if it is *not* followed by `hound`.  Thus
the `grey` just before `socks` is matched.

****** Lookbehind

Positive lookbehind (`?<=`) checks that its subpattern *could* match
immediately to the left of the current position in
the text string.

```
(pregexp-match-positions "(?<=grey)hound"
  "the hound in the picture is not a greyhound")
=> ((38 . 43))
```

The regexp `(?<=grey)hound` matches `hound`, but only if it is
preceded by `grey`.

Negative lookbehind
(`?<!`) checks that its subpattern
could not possibly match immediately to the left.

```
(pregexp-match-positions "(?<!grey)hound"
  "the greyhound in the picture is not a hound")
=> ((38 . 43))
```

The regexp `(?<!grey)hound` matches `hound`, but only if
it is *not* preceded by `grey`.

Lookaheads and lookbehinds can be convenient when they
are not confusing.

**** An extended example

Here's an extended example from
Friedl~\cite[p 189]{friedl:regex}
that covers many of the features described
above.  The problem is to fashion a regexp that will
match any and only IP addresses or *dotted
quads*, ie, four numbers separated by three dots, with
each number between 0 and 255.  We will use the
commenting mechanism to build the final regexp with
clarity.  First, a subregexp `n0-255` that matches 0
through 255.

```
(define n0-255
  "(?x:
  \\d          ;  0 through   9
  | \\d\\d     ; 00 through  99
  | [01]\\d\\d ;000 through 199
  | 2[0-4]\\d  ;200 through 249
  | 25[0-5]    ;250 through 255
 )")
```

The first two alternates simply get all single- and
double-digit numbers.  Since 0-padding is allowed, we
need to match both 1 and 01.  We need to be careful
when getting 3-digit numbers, since numbers above 255
must be excluded.  So we fashion alternates to get 000
through 199, then 200 through 249, and finally 250
through 255.\f{Note that
\ifx\\PLAINTEX
`n0-255`
\else
\var{n0-255}
\fi
lists prefixes as
preferred alternates, something we cautioned against in
sec \ref{alternation}.  However, since we intend
to anchor this subregexp explicitly to force an overall
match, the order of the alternates does not matter.}

An IP-address is a string that consists of
four `n0-255`s with three dots separating
them.

```
(define ip-re1
  (string-append
    "^"        ;nothing before
    n0-255     ;the first n0-255,
    "(?x:"     ;then the subpattern of
    "\\."      ;a dot followed by
    n0-255     ;an n0-255,
    ")"        ;which is
    "{3`"      ;repeated exactly 3 times
    "$"        ;with nothing following
   ))
}

Let's try it out.

```
(pregexp-match ip-re1
  "1.2.3.4")
=> ("1.2.3.4")

(pregexp-match ip-re1
  "55.155.255.265")
=> #f
```

which is fine, except that we also
have

```
(pregexp-match ip-re1
  "0.00.000.00")
=> ("0.00.000.00")
```

All-zero sequences are not valid IP addresses!
Lookahead to the rescue.  Before starting to match
`ip-re1`, we look ahead to ensure we don't have all
zeros.  We could use positive lookahead
to ensure there *is* a digit other than
zero.

```
(define ip-re
  (string-append
    "(?=.*[1-9])" ;ensure there's a non-0 digit
    ip-re1))
```

Or we could use negative lookahead to
ensure that what's ahead isn't composed
of *only* zeros and dots.

```
(define ip-re
  (string-append
    "(?![0.]*$)" ;not just zeros and dots
                 ;(note: dot is not metachar inside [])
    ip-re1))
```

The regexp `ip-re` will match
all and only valid IP addresses.

```
(pregexp-match ip-re
  "1.2.3.4")
=> ("1.2.3.4")

(pregexp-match ip-re
  "0.0.0.0")
=> #f
```

**** References

\nocite{sre,nregex,kleene:regexp}

*** apropos

*** assert

*** awk

*** binary-search

*** binary-tree

*** destructive-ops

*** format

*** graphs

*** io

*** let-optionals

*** load-module

*** load

*** mergesort

*** set

*** strings

*** utils

*** uuid

*** xml

*** srfi-0: COND-EXPAND, feature-based conditional expansion

*** srfi-2: AND-LET*

*** srfi-8: RECEIVE, binding to multiple values

*** srfi-9: Defining record types

*** srfi-13: String libraries

*** srfi-14: Character-set library

*** srfi-16: CASE-LAMBDA, syntax for procedures of variable arity

*** srfi-19: Time data types and procedures

*** srfi-25: Multi-dimensional array primitives

*** srfi-28: Basic format strings

*** srfi-43: Vector library

*** srfi-69: Hash tables
